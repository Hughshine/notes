# 同步

（线程间的同步）基于共享内存的方案，无法在分布式系统上适用。分布式系统上，很难区分两个事件发生的先后。

基于时钟（Clock Sync）：物理时钟，相对顺序（逻辑时钟）。对于不关注真实时间的算法，逻辑时钟即可；对于需要考察真实时间的算法，使用物理时钟（一定会有clock skew的问题）。

如何同步对共享内容的访问：互斥

选举：确定分布式系统中的协调者

## 物理时钟同步

1. clock daemon 不断去问其他机器的clock values，根据返回值提供调整意见

？

## 逻辑时钟

如何去维护一个关于系统全局行为的，happened-before relation 的视图？

1. 相同线程前后发生的事件，具有逻辑时间上的先后关系
2. 消息的接收，建立不同线程相应事件的逻辑时间关系：sender a < receipt b

需要思考：没有一个全局时钟时，我们如何维护（每个线程的）逻辑时钟的一致

Lamport's Algorithm: 每个线程具有local counter c

1. 线程中事件接续发生，c++（显然保持了单线程的逻辑序）
2. 发送消息时，消息带有该线程的时间戳ts
3. 接受消息时，接受线程调整其c至max(c', ts)+1（保证了不同线程事件的逻辑时间）
4. 线程id用于处理时间戳相同的情况。

其实此时，不同线程的时间戳，即使相同，也可能是不可比的。数字大小只表示“事件发生次数”...。【两个事件，仅根据时间戳，不能直接确定两者的先后关系（进而是因果关系）】【逻辑先后，定义于同步】

## 向量时间戳

维护一个对所有线程发生时间的知识（也就是额外记录其他线程发生事件的次数）。传消息是同时发送所有已知的消息（自己的时间戳额外加1）（也表示这个消息可能依赖的其他线程的已有 行为）（send/recv表示一次同步，这个数组就是所有之前发生的事件）；接受是也将对每个线程的已知知识更新到相应最大（对自己的时间戳最后额外+1【表示send与recv的同步】）。【只是允许了一种推理】

（如果不在发生非send/recv时额外进行递增）这里的每一个时间应该只是send/recv发生的次数了。事件类别缩小。

---

此时可以类似地强制消息的同步关系被保持（因果序广播情景）【这种情景下，使问题更简单，recver不额外+1（+1我认为也可以保持...）】。每一个线程，只当接受的消息的所有可能依赖的其他线程发生的事件得到同步，才会将消息进一步递交给应用。要满足两个条件：

1. 消息中，sender以外的其他线程的时间戳，都比msg记录的时间要小（已经同步了可能依赖的事件）
2. 已同步sender线程之前的所有消息，这个消息时下一个期待的sender的消息，$ts(m)[i]=VC_j[i]+1$

> 是否真正拥有因果关系，需要看信息的内容。

## 互斥

在分布式系统中，线程希望对某些资源进行独占性访问，基础方案：

1. 中心化：协调者管理一个请求队列，维护request, grant, release
   1. 优势：正确性显然，公平，无饥饿，易于实现
   2. 缺点：中心化本身的缺点，单点故障、性能瓶颈
      1. 同时，进程无法区分没有返回信息这件事，究竟意味着需要等待还是意味着协调者dead
      2. 持有锁的进程死了，协调者也没有办法知道（可能可以拓展协议）
2. 去中心化（P2P）
3. 无拓扑分布式
   1. 基于已建立的happens-before relation
   2. 要进入临界区时。广播消息（临界区；进程号；当前时间）
   3. 收到消息
      1. 不在临界区，并且没有要进入相应临界区，reply OK
      2. 已经在临界区，queue the msg，延迟reply
      3. 将要进入临界区，则比较时间戳，对方更小，reply OK；我方更大，queue the msg，延迟reply
      4. 出临界区后，向队列元素reply OK，清空
   4. 缺点：
      1. 故障可能性扩大，任何一个机器坏掉就不行（可以考虑修改协议，都进行应答）
      2. 复杂、昂贵...
      3. 如果网络不可靠，需要每个进程额外进行维护
4. 环拓扑分布式（Token-ring algorithm）：拿到token，允许进入
   1. 一个环对应一个临界区
   2. 持有token，若不需要进入临界区，向下传递；需要，则持有等待
   3. 问题：令牌丢失的处理是困难的；需要每个进程都维护当前的配置信息（环），定期询问前置线程，获取token在环中的状态信息。

比较：每次进入临界区产生的消息传递（临界区视角）；delay可能需要等待的消息传递（拥有临界区访问请求的进程视角），MTTU，message transfer time units；问题

1. centralized:
   1. 3（request / grant / release）
   2. 2
   3. 协调者crash
2. distributed
   1. 2(n-1) （N-1 request + N-1 grant）
   2. 2(n-1)
3. token-ring
   1. 1, ..., inf （token的传递不是根据进入临界区的需要的）
   2. 0~n-1，可能不用等或者等一圈

互斥访问问题，是一个显然地中心化决策的问题。上述所有算法都受到crash的影响，都必须提供针对crash的机制；常用的方案是中心化策略。

## 选举算法

如何（动态地）选择某个进程成为协调者？如果动态选择协调者，我们如何确定其中心化/分布式的程度呢？采用协调者的系统，真的会比其他方法更鲁棒吗？

选举问题：假设每一个进程都有一个uid，每个进程都知道其他进程的uid（但是不知道它们的运行情况），问题尝试去定位具有**最大标识符**的进程

Bully 算法:

1. 选举发生：当某个进程发现原有的协调者不再respond；或者崩溃的进程重启后可以重新发起选举（似乎不能很好地处理partition）
   1. P_k 给所有id比它大的进程发election msg，没有reply则成功，通知所有其他进程
   2. 如果接收到更大的进程的回应，不再成为协调者

环算法：

1. 接力一个election message，（必须成功传给某个后继），消息中增加自己uid
2. 转过一圈（当某个进程收到一个election message，包含自己），改为发送coordicator消息，通知每个人协调者是谁（具有最大uid的那个），其他人是这个新的ring的成员。新消息转过一圈后，删除。

两个进程发起election是没关系的；进程在election过程crash也没关系（没有影响或者重来）。reboot，可以重新发起选举。

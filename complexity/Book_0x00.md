只听课听不懂，记录一些读书笔记。

# Intro: computational complexity, a modern approach

“计算”在二十世纪有了明确的定义，不同计算模型出现，并且它们能力的一致性得到证明，于是我们更少关注计算模型本身，转而考虑一个通用模型，考察其上的计算（脱离计算模型考察计算）。

可计算性是一个重要问题，但这门课较少关注。这门课主要关注复杂性。

1. 计算的效率：相同问题不同算法的比较
   1. 算法的效率以基本操作的scale与输入大小的关系衡量
   2. 对于十进制乘法的两个算法（repeated addition）与（grade-school algorithm），设1bit与1bit的加法与乘法的复杂度为1，输入的大小为$n$，则前者复杂度为$10^n$，后者为$2n^2$
      1. n次nbit与1bit的乘法 -> n次*n次1bit与1bit的(乘法+加法) ~ 2n^2
      2. (n-1)次nbit与nbit的加法 ~ 2n
   3. 独立集$2^n$，可能没有更有效算法 -- 证明算法的下界
2. 问题的难度：实现问题算法的难度的下界
   1. 这种证明还是较少的，大多数时候，还是在研究不同问题的关联

一些有趣问题的例子：
1. P 与 NP <=> efficient search 与 exhaust search 
2. 随机算法对计算复杂度的提升的限度
3. 近似算法对复杂度的提升，新的算法正确性的定义
4. 困难问题与密码学：利用困难本身
5. 量子计算模型
6. 从计算的角度看待证明：自动化证明，概率可检测证明，证明复杂度...

> 数学里没有无知：我们可以清楚计算的限度，衡量可能性。
> You can find it by pure reason, for in mathematics there is no ignorance.
\documentclass[UTF8, 8pt, a4paper ]{ctexart}
\usepackage[utf8]{inputenc}
\usepackage[left = 15mm, right = 15mm, top = 20mm, bottom= 20mm]{geometry}

\usepackage{ksafe-lin-proof}
\newcommand{\absHistSet}[1]{\mathcal{S}\llbracket #1 \rrbracket}

\usetikzlibrary{decorations.pathmorphing}
\newcommand\xrsquigarrow[1]{%
	\mathrel{%
		\begin{tikzpicture}[%
			baseline={(current bounding box.south)}
			]
			\node[%
			,inner sep=.44ex
			,align=center
			] (tmp) {$\scriptstyle #1$};
			\path[%
			,draw,<-
			,decorate,decoration={%
				,zigzag
				,amplitude=0.7pt
				,segment length=1.2mm,pre length=3.5pt
			}
			]
			(tmp.south east) -- (tmp.south west);
			\path[draw] ($ (tmp.south west)+(0,-0.7mm) $)--($ (tmp.south west)+(0,0.7mm) $);
			
		\end{tikzpicture}
	}
}

\newcommand{\circline}{
	\mathrel{%
		\raisebox{0.15mm}{
		\begin{tikzpicture}
%			[%
%			baseline={(current bounding box.south)}
%			]
			\draw[line width=0.35pt] (0,0) circle (2pt);
			\draw[line width=0.35pt] (-1.2mm, 0)--(1.2mm, 0);
		\end{tikzpicture}\ }
	}
}

%\newcommand{\clientSet}{\mathcal{C}}
%\newcommand{\replicaSet}{\mathcal{R}}
%\newcommand{\faultyClients}{\mathfrak{C}}
%\newcommand{\faultyReplica}{\mathfrak{R}}

\newcommand{\clientSet}{\mathcal{C}_{\textit{ok}}}
\newcommand{\replicaSet}{\mathcal{R}_{\textit{ok}}}
\newcommand{\faultyClients}{\mathcal{C}_{\textit{bad}}}
\newcommand{\faultyReplica}{\mathcal{R}_{\textit{bad}}}

\newcommand{\inbuf}{\textit{Inbuf}\hspace{0.7mm}}
\newcommand{\phymap}[1]{\ulcorner #1 \urcorner}
\newcommand{\addrSet}{\mathcal{A}}

\begin{document}
	\fontsize{8pt}{8pt}
	\setlength{\baselineskip}{14pt}
	
	
%	$ \circ $ $ \circline $
	
\begin{small}
		
%	$ (W,S) \longmcltstep{\ H\ }{t,P} (W,S) $
	
%	$ (W,S) \longmcltstep{\ aslhdajshdkajshdj\ }{t,P} (W,S) $
	
%	$ (W,S) \longmcltstep{\ \ \ }{e} (W,S) $




\textbf{在同步语句只包含\texttt{lock}与\texttt{unlock}的语言上，验证Deadlock.}
	\begin{itemize}
		\item 
	\end{itemize}
	% \textbf{在此简单记录一些易于混淆的概念}
	% \begin{itemize}
	% 	\item 死锁的四个条件：互斥条件（有限资源），占有且等待（程序设计（不会异步的先做检测、做其他事，而是直接等）），不可剥夺（语言特性（由语义控制）），循环等待（各线程相互持有其他线程需要的资源：图中的环）
	% 	\item 看起来死锁的非死锁：一个线程结束、未放弃某资源，或者就是一直不释放某资源。编程错误，不是死锁问题。
	% 	\item 活锁与死锁差的很远，基本没有关系。
	% 	\item Banker's algorithm: 死锁避免算法，预设是可以知道每个线程需要的资源上限，并假定只要线程拥有了max，可以最终释放资源。【没什么关系】
	% \end{itemize}
	
	\pagebreak

	\section{Basic Technical Setting for Incorrectness Concurrent Logic(V1.0)}
	
	\newcommand{\auxFuncs}{\mathcal{F}_\textsf{aux}}
	
	\subsection{Syntax of the Programming Language}
	
		\begin{longtable}{rcl}
			\hline
				$ val $ & $ \in $ & $ \textit{Val} $ \\
				
				$ParId$ & $ ::= $ & $\textit{Nat}^{+}$ \\

				$lock$ & $ \in $ & $Lock$ \\

				$ x, y, pid, pid', l...  $ & $ \in $ & \textit{PVar} \\ 
				\hline
				\multicolumn{3}{c}{\textbf{Figure 1.} Basic Types} \\
		\end{longtable}
				
				
		\begin{longtable}{rcl}
			% \multicolumn{3}{@{}l}{}\\

			\hline
				$ (\!\textit{Stmt})\ C $ & ::= & $ \textbf{skip}$\\ 
					&& $ c $\\ 
					&& $ \overline{c}  $\\
					&& $\textbf{if}\;b\;\textbf{then}\;c_0\;\textbf{else}\;c_1(pid)$\\
					&& $\textbf{while}\;b\;\textbf{do}\;c(pid)$\\
					% && $\langle C \rangle$\\
					&& $C_1 || C_2$\\ 
				
				$ (\!\textit{Basic command})\ c $ & ::= & $ x := E(pid)  $\\
					% && $ \textbf{wait}(l)(pid) $\\
					&& $l = \textbf{decl\_lock()}(pid)$\\
					&& $\textbf{lock}(l)(pid)$\\
					&& $\textbf{unlock}(l)(pid)$\\
					&& $...$\\
				
				% $ (\!\textit{Par command Extension})\ C_1 || C_2(pid) $ & ::= & $ pid' = subproc(pid);C_1;endproc(pid')\;||_0\;pid' = subproc(pid);C_2;endproc(pid')  $\\ 
				
				
				$ (\!\textit{Auxiliary command})\ \overline{c} $ & ::= & $ pid' = \textbf{subproc}(pid) $\\ 
					&& $ \textbf{endproc}(pid)  $\\
					% && $ newpid\;pid' :=  in c$
				\hline
				
				\multicolumn{3}{c}{\textbf{Figure 2.} Syntax of the Programming Language} \\
			
		\end{longtable}
	
	
	对于表一与表二的一些说明:
	\begin{itemize}
		\item pid参数, 辅助指令的引入，是为了方便并发程序分析：在并发程序段随机执行任意指令时，我们都需要确定它所属线程。因而，所有Basic Command和Auxiliary Command都拥有pid作为参数。GPPL（用户程序）很容易转换为表格二中拓展的语言：程序转换包括提供initpid（在程序的开始和结尾加入辅助指令）, 在每一个并发线程的开始与结束加入辅助指令，在每一个basic command后隐式添加这个线程在最初创建的pid作为参数。我们只需要分析表格二中的语言即可。
		这些指令（和相关信息），可以理解为“由操作系统执行与保管”。
		\item 令res, pid和一般变量命名不相同，避免名字冲突——我们认为，pid对于程序本身是透明的。
		\item 将设计这样的语义：线程用\texttt{lock}求锁，会一直等待锁空闲（并被该线程抢走）；\texttt{unlock}未拥有的锁，意味着程序出错，写程序时应避免此问题（这里可以额外设置状态）。
	\end{itemize}
	
	
	\subsection{States and Attribute}
	
		\begin{longtable}{rcl}
			\hline			
			
			$ (\!\textit{Mem})\ Mem $ & $ \subseteq $ & $ \textit{PVar} \rightharpoonup \textit{Val} $\\
				
			$ (\!\textit{ParidMem})\ ParM $ & $ \subseteq $ & $ \textit{PVar} \rightharpoonup \textit{ParId} $\\

			$ (\!\textit{LockMem})\ LockM $ & $ \subseteq $ & $ \textit{PVar} \rightharpoonup \textit{Lock} $\\

			$ (\!\textit{LockHost})\ LockHost $ & $ \subseteq $ & $ {\textit{Lock}} \rightharpoonup (\{\perp\}\cup ParId) $\\

			$ (\!\textit{ParRequest}) \ ParRequest $ & $\subseteq $& $ ParId \rightharpoonup (\{\perp\} \cup Lock) $\\

			% $ (\!\textit{ParDependency})\ Dependency  $ &$ \subseteq $ & $ ParId \times ParId $\\		

			$ (\!\textit{ProgramState})\ \sigma  $ &$ ::= $ & $ (Mem, ParM, LockM, LockHost, ParRequest)$\\

			\hline
			
			\multicolumn{3}{c}{\textbf{Figure 3.} States} 
		\end{longtable}

		Here are some notes for {figure 3}（设计思路）:
		\begin{itemize}
			\item Mem和ParM和LockM是分离的内存。
			\item LockHost用于记录锁的归属，$\perp$ 意味着无归属；ParRequest用于记录线程对锁的访问，$\perp$意味着无依赖。
		\end{itemize}
	

		在某个状态$\sigma$下，我们可以定义线程状态。

		\begin{definition}[\textbf{Deadlock}]\ $Deadlock(\sigma):= TransitiveClosure(\sigma.LockHost \cup \sigma.ParRequest)\;\textit{is anti-reflexive}.$	
		\end{definition}

		\begin{definition}[\textbf{Blocked}]\ $Blocked(pid, \sigma):= \textbf{let}\;lock=\sigma.ParRequest(pid).\;lock \not= \perp \wedge \neg LockFree(lock, \sigma)$				
		\end{definition}


		\begin{definition}[\textbf{UnBlocked}]\ $Unblocked(pid, \sigma):= \neg Blocked(pid, \sigma)$	
			
		\end{definition}

		% \begin{definition}[\textbf{Own}]\ $Own(pid, res, \sigma):= ResHost(res) = pid$	
			
		% \end{definition}

		\begin{definition}[\textbf{LockFree}]\ $LockFree(lock, \sigma):= \sigma.LockHost(lock) = \perp$	
			
		\end{definition}


	\kspace
	
	\subsection{Operational Semantics}
	
	
	
	
	\begin{comment}
	$ \textsf{stop-faultyClt}(\sigma, t) \ \triangleq\ \left\{
	\begin{array}{ll}
		(t, \texttt{stop}) & \sigma(\textit{faulty}) = \textbf{true} \land  \sigma_o(\textit{role}) = \texttt{client}\\
		\tau & \textit{o.w.} \\
	\end{array}
	\right. $
	\end{comment}
	\subsubsection{Semantics for Expressions}

	Note that expression needs to be evaluated only when it is not blocked. 
	
	% \color{red} 目前不确定，可能还是需要（表达式的小步语义的前提也都要加上unblocked，（从内存中取值的那一步需要）... 虽然在语义中目前没有考虑。（如果不默认这一点，目前给出的语义可能是不sound的，因为可以从内存中取值代替了变量，但实际不能做这件事（非原子的））\color{black} 
	
	\subsubsection{Semantics for Commands}

	每一个语句后，都有对ParRequest的调整，原因是：在并发情况下，可能由多个线程抢一个锁（他们都处于等待状态，表现为ParRequest(pid)都一致）。
	我们选择的下一个被调度的程序，抢到了锁，因而不再“等待锁”，反而是它占有了这把锁（LockHost因而也需要调整）。任何一个语句都可以导致这个状态的转变。
	
	每个指令，只有在它没有等待、或者它等待的资源已经释放时，才有下一步的语义，这由每一项规则的前提\textbf{$Unblocked(pid, \sigma)$}控制。
	
	同时，区分每条指令可以执行时，是情况(1)它等待的资源已经释放、并被它抢到、然后执行的这条指令，还是情况
	(2)之前没有等待资源、直接执行的这条指令。
	这两个情况的区别是，这一条语句的前一条是否是没有成功、在停等的lock()。
	情况(1)需要对进程对锁的依赖、与锁的占有权进行调整；情况(2)不需要调整。
	这个区分在语义规则中，体现为每个语句有两个版本，Locked与Unlocked，分别对应情况(1)与情况(2)。

	对于重复lock（即拥有锁的线程重复lock相同的锁），我取后续的lock为无效这一语义。

	对于非法的unlock（即线程对自己没有权限的锁unlock），我取让程序abort这一语义。% TODO: 是abort 还是当作无事发生？

	\vspace{0.2cm}

	% Here are some notes:
	% \begin{itemize}
	% 	\item Mem和ParidMem和ResMem是分离的内存。
	% 	\item ResHost用于记录资源的归属，$\perp$ 意味着无归属；ParRequest用于记录线程的需求。
	% \end{itemize}
	
	\begin{center}

		\kspace
		$
		\inferrule[Assign-Locked]
		{  Unblocked(pid, \sigma)\;\;\;\textbf{let}\; lock = \sigma.ParRequest(pid).\;lock\not=\perp}
		{(x:=E(pid), \sigma)\longrightarrow(\textbf{skip}, \sigma(Mem\{x\rightsquigarrow n\}, LockHost\{lock \rightsquigarrow pid\}, ParRequest\{pid\rightsquigarrow \perp\})}
		$

		\kspace
		$
		\inferrule[Assign-unLocked]
		{  Unblocked(pid, \sigma)\;\;\;\textbf{let}\; lock = \sigma.ParRequest(pid).\;lock=\perp}
		{(x:=E(pid), \sigma)\longrightarrow(\textbf{skip}, \sigma(Mem\{x\rightsquigarrow n\}\})}
		$
	

		\kspace
		$  % 一样，可能由lock(l1); decl_lock(l2);的情况
		\inferrule[decllock-locked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; lock = \sigma.ParRequest(pid).\;lock\not=\perp}
		{(l := \textbf{decl\_lock}()(pid), \sigma)\longrightarrow(skip, \sigma(Lock(l\rightsquigarrow new\;Lock()), LockHost(lock\rightsquigarrow pid, Lock(l)\rightsquigarrow \perp), ParRequest(pid\rightsquigarrow \perp))}
		$


		\kspace
		$  % 一样，可能由lock(l1); decl_lock(l2);的情况
		\inferrule[decllock-unlocked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; lock = \sigma.ParRequest(pid).\;lock=\perp}
		{(l := \textbf{decl\_lock}()(pid), \sigma)\longrightarrow(skip, \sigma(Lock(l\rightsquigarrow new\;Lock()), LockHost(Lock(l)\rightsquigarrow \perp))}
		$

		\kspace
		$  % 可能出现 lock(l1), lock(l2)的情况. 可能申请了同意把锁，这一点要处理。
		   % 如果一个线程，没有处于blocked状态，且刚刚上了锁、锁已经非空，这意味着它可以抢锁。同时，这个线程又可以成功上一把新锁。
		   % 执行这个语句后，该线程不再处于停等状态
		\inferrule[Lock-SUCC-Locked]
		{Unblocked(pid, \sigma)\;\;\; LockFree(l, \sigma)\vee \sigma.LockHost(l)=pid\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}
		{(\textbf{lock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l \rightsquigarrow pid, l' \rightsquigarrow pid), ParRequest(pid\rightsquigarrow \perp)))}
		$

		
		\kspace
		$  % 可能出现 lock(l1), lock(l2)的情况. 
		   % 如果一个线程，没有处于blocked状态，且也没有处于停等状态，此时申请一把新锁；
		   % 新锁无人占用。这意味着这个线程可以成功上新锁。
		   % 执行这个语句后，线程不处于停等状态。
		\inferrule[Lock-SUCC-UnLocked]
		{Unblocked(pid, \sigma)\;\;\; LockFree(l, \sigma)\vee \sigma.LockHost(l)=pid\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}
		{(\textbf{lock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l \rightsquigarrow pid)))}
		$

		\kspace
		$  % 线程处于停等状态，且等候的锁已空；此时线程申请一把新锁，新锁不属于它、非空、属于别人，所以线程达到新的停等状态。
		   % 旧锁属于该线程、该线程依赖新锁。
		\inferrule[Lock-Fail-Locked]
		{Unblocked(pid, \sigma)\;\;\;\neg LockFree(l, \sigma)\wedge \sigma.LockHost(l)\not=pid\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}
		{(\textbf{lock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l' \rightsquigarrow pid), ParRequest(pid\rightsquigarrow l)))}
		$
		
		% TODO: Start from here

		\kspace
		$  % 线程处于正常执行状态，此时线程申请一把锁。这把锁被别人占有，所以线程陷入新的停等状态。
		\inferrule[Lock-Fail-UnLocked]
		{Unblocked(pid, \sigma)\;\;\; \neg LockFree(l, \sigma)\wedge \sigma.LockHost(l)\not= pid\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}  
		{(\textbf{lock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(ParRequest(pid\rightsquigarrow l)))}
		$

		
		\kspace
		$ % 线程处于停等状态，等待的锁已空闲，线程解锁一把自己拥有的锁。因而取消停等状态、获得等待的锁，并释放指定的锁。
		  % 这个规则用于两把锁不一致的情况
		\inferrule[Unlock-Locked-1]
		{Unblocked(pid, \sigma)\;\;\; Own(pid, l, \sigma)\wedge l\not=l'\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}
		{\textbf{unlock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l' \rightsquigarrow pid, l \rightsquigarrow \perp),  ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		$ % 线程处于停等状态，等待的锁已空闲，线程解锁一把自己拥有的锁。因而取消停等状态、获得等待的锁，并释放指定的锁。
		  % 这个规则用于
		  % 如果等待的锁和释放的锁一致，则将锁释放。
		\inferrule[Unlock-Locked-2]
		{Unblocked(pid, \sigma)\;\;\; Own(pid, l, \sigma)\wedge l=l'\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}
		{\textbf{unlock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l \rightsquigarrow \perp),  ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		$ % 线程处于正常状态，解锁一把它拥有的锁，成功解锁
		\inferrule[Unlock-UnLocked]
		{Unblocked(pid, \sigma)\;\;\; Own(pid, l, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}
		{\textbf{unlock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l \rightsquigarrow \perp)))}
		$



		% \kspace
		% $ % 需要一条Rule处理UnLock不拥有的锁。目前没有给相当于Get Stuck.
		% \inferrule[Unlock-Fail]
		% {Unblocked(pid, \sigma)\;\;\; Own(pid, l, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}
		% {\textbf{unlock}(l)(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l \rightsquigarrow \perp)))}
		% $

		\kspace
		$  % 线程pid正在停等，停等后要创建子线程。目前停等的资源已经空闲。该线程获得该锁。
		\inferrule[SubProc-Locked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}
		{(pid' = \textbf{subproc}(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(ParM(pid' \rightsquigarrow nextpid()), LockHost(l'\rightsquigarrow pid), ParRequest(pid\rightsquigarrow \perp, pid'\rightsquigarrow\perp)))}  % TODO: nextpid()
		$

		\kspace
		$  % 线程pid处于正常状态，正要创建子线程。子线程创建成功。
		\inferrule[SubProc-UnLocked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}
		{(pid' = \textbf{subproc}(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(ParM(pid' \rightsquigarrow nextpid()), ParRequest(pid'\rightsquigarrow\perp)))}  % TODO: nextpid()
		$

		\kspace
		$ % 可能有lock(l)(pid); endproc(pid); 这会导致锁再无法释放（也可以使用将持有的锁全部释放的语义，但是觉得不好。）。
		\inferrule[EndProc-Locked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'\not=\perp}  
		{(\textbf{endproc}(pid), \sigma) \longrightarrow (\textbf{skip}, \sigma(LockHost(l'\rightsquigarrow pid), ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		$ % 从普通状态正常结束，什么都不用动。
		\inferrule[EndProc-UnLocked]
		{Unblocked(pid, \sigma)\;\;\;\textbf{let}\; l' = \sigma.ParRequest(pid).\;l'=\perp}  
		{(\textbf{endproc}(pid), \sigma) \longrightarrow (\textbf{skip},\sigma))}
		$


		if/while, 因为要evaluate布尔表达式，也要区分运行前的状态。
		
		\kspace
		$
		\inferrule[IF-True-Locked]  % 表达式需要unblocked
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = True}
		{ (\textbf{if}\;b\;\textbf{then}\;c_0\;else\;c_1, \sigma)\longrightarrow (c_0, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$
		
		\kspace
		
		$
		\inferrule[IF-True-UnLocked]  % 表达式需要unblocked
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = True}
		{ (\textbf{if}\;b\;\textbf{then}\;c_0\;else\;c_1, \sigma)\longrightarrow (c_0, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		
		$
		\inferrule[IF-False-Locked]  % 表达式需要unblocked
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = False}
		{ (\textbf{if}\;b\;\textbf{then}\;c_0\;else\;c_1, \sigma)\longrightarrow (c_1, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$

		
		\kspace
		
		$
		\inferrule[IF-False-Unlocked]  % 表达式需要unblocked
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = False}
		{ (\textbf{if}\;b\;\textbf{then}\;c_0\;else\;c_1, \sigma)\longrightarrow (c_1, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$
		\kspace
		
		$
		\inferrule[While-True-Locked]
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = True}
		{(\textbf{while}\;b\;\textbf{do}\;c, \sigma)\longrightarrow(c;\textbf{while}\;b\;\textbf{do}\;c, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		$
		\inferrule[While-True-UnLocked]
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = True}
		{(\textbf{while}\;b\;\textbf{do}\;c, \sigma)\longrightarrow(c;\textbf{while}\;b\;\textbf{do}\;c, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$

		\kspace
		$
		\inferrule[While-False-Locked]
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = False}
		{(\textbf{while}\;b\;\textbf{do}\;c, \sigma)\longrightarrow(\textbf{skip}, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$
		
		\kspace
		$
		\inferrule[While-False-UnLocked]
		{ Unblocked(pid, \sigma)\;\;\;\;\;\;\llbracket b \rrbracket_{\sigma} = False}
		{(\textbf{while}\;b\;\textbf{do}\;c, \sigma)\longrightarrow(\textbf{skip}, \sigma(ParRequest(pid\rightsquigarrow \perp)))}
		$

		% \kspace
		% $
		% \inferrule[Atom]  %TODO: 需要加unblocked吗
		% { Unblocked(pid, \sigma)\;\;\;\;\;\;(C, \sigma)\longrightarrow(C', \sigma')}
		% {(\langle C \rangle, \sigma)\longrightarrow(C', \sigma')}
		% $
		\kspace
		Seq Rule与Par Rule，不需要看是否Blocked或分情况，这件事“前提”会去做。

		$
		\inferrule[Seq1]
		{ (c_0, \sigma) \longrightarrow (c_0', \sigma') }
		{ (c_0;c_1, \sigma) \longrightarrow (c_1, \sigma') }
		$
		
		\kspace

		$
		\inferrule[Seq2]
		{\;}
		{ (\textbf{skip};c_1, \sigma) \longrightarrow (c_1, \sigma) }
		$

		\kspace
		$
		\inferrule[Par1]  %TODO: 需要加unblocked吗: 应该不需要
		{ (C_0, \sigma) \longrightarrow (C_0', \sigma)}
		{ (C_0 || C_1, \sigma) \longrightarrow (C_0' || C_1, \sigma)}
		$
		\kspace

		$
		\inferrule[Par2]  %TODO: 需要加unblocked吗：应该不需要
		{ (C_1, \sigma) \longrightarrow (C_1', \sigma)}
		{ (C_0 || C_1, \sigma) \longrightarrow (C_0 || C_1', \sigma)}
		$

	\end{center}

	

% %	\begin{itemize}
% %		\item crash行为定义成修改程序为skip
% %		\item 如果t是faulty client, 则产生事件$ (t, \texttt{stop}) $, 否则silent. 因为在描述byznearizability时只需要faulty client的stop标记
% %	\end{itemize}
		
% 	\subsubsection{Network Misbehave Rules}
	
% 	\vspace{0.2cm}
	
% 	\begin{center}
% 		$ \inferrule[Msg-Lose]
% 		{ (\addrSet_\textit{ori}, \addrSet_\textit{cur}, m) \in M \\ pa \in \addrSet_\textit{cur} }
% 		{M \xrsquigarrow{\ \ \ }  (M \setminus (\addrSet_\textit{ori}, \addrSet_\textit{cur}, m)) \cup (\addrSet_\textit{ori}, \addrSet_\textit{cur} \setminus \{ pa \}, m)}
% 		$
% 		\qquad		
% 		$ \inferrule[Msg-Dup]
% 		{ (\addrSet_\textit{ori}, \addrSet_\textit{cur}, m) \in M \\ pa \in \addrSet_\textit{ori}   }
% 		{M \xrsquigarrow{\ \ \ }   (M \setminus (\addrSet_\textit{ori},\addrSet_\textit{cur}, m)) \cup (\addrSet_\textit{ori}, \addrSet_\textit{cur}\cup\{ pa \}, m) }
% 		$
% 	\end{center}
	
	
	
% %	从Dup规则可以看到，mc可能原不打算发给$ t $，也可以凭空产生发送给t。这种行为可由网络故障引起。
	
% 	\subsubsection{Thread Transition Rules}
% 	\noindent \textbf{Thread transition inside method call:}
	
% 	\vspace{0.2cm}
	
% 	\begin{center}
% 		$ 
% 		\inferrule[Ret]
% 		{	\llbracket E \rrbracket_{ \sigma_o \uplus \sigma_l} = {val} }
% 		{ (\textbf{E}[\textbf{return }E], (\sigma_c, \sigma_o, (\sigma_l, x, C)), M ) \longcltstep{(t, \texttt{ok}, val)}{t, P} (C, (\sigma_c\{ x \rightsquigarrow \textit{val}\}, \sigma_o, \circ),  M ) }
% 		$
% %		

% 		\kspace
		
% 		$
% 		\inferrule[Assn]
% 		{ \sigma = \sigma_o \uplus \sigma_l \\ \llbracket E \rrbracket_{ \sigma } = val \\ \sigma_o' \uplus \sigma_l' = \sigma\{ x \rightsquigarrow val \} \\ \textsf{dom}(\sigma_l) = \textsf{dom}(\sigma_l') }
% 		{ (\textbf{E}[x \assign E], (\sigma_c, \sigma_o, (\sigma_l, x, C)),  M) {\longcltstep{ \ \ \  }{t, P}\ (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o', (\sigma_l', x, C)),  M  ) }}
% 		$
		
		
% 		\kspace
		
% 		$ \inferrule[Stop-Clt]
% 		{ \sigma_o(\textit{faulty}) = \textbf{true}  \\ \sigma_o(\textit{role}) = \texttt{client} }
% 		{(\textbf{E}[\textbf{stop}], (\sigma_c, \sigma_o, \kappa), M) \longcltstep{(t, \texttt{stop}) }{t,P} (\textbf{skip}, (\sigma_c, \sigma_o, \kappa), M) } 
% 		$
% 		\ 
% 		$ \inferrule[Stop-Rpc]
% 		{ \sigma_o(\textit{faulty}) = \textbf{true}  \\ \sigma_o(\textit{role}) = \texttt{replica} }
% 		{(\textbf{E}[\textbf{stop}], (\sigma_c, \sigma_o, \kappa), M) \longcltstep{\ \ \ }{t,P} (\textbf{skip}, (\sigma_c, \sigma_o, \kappa), M) } 
% 		$
		
		
% 		\begin{comment}
		
% 		\kspace
		
% 		$ \inferrule[Send]
% 		{ \sigma = \sigma_o \uplus \sigma_l \\   to = \eevalu{E_{to}}{\sigma} \\ mc = \eevalu{E_{mc}}{\sigma} \\ mc \in P.\mathcal{M} \\  }
% 		%
% 		{(\textbf{E}[\textbf{send}(E_{to}, E_{mc})], (\sigma_c, \sigma_o, (\sigma_l, x, C)),  M) \longcltstep{ \ \ \ }{t, P} (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o, (\sigma_l, x, C)),  M \uplus \{ (t, to, \textbf{false}, mc) \} ) } $
% 		\end{comment}
% 		\kspace
		
		
% 		$ \inferrule[Send]
% 		{ \sigma = \sigma_o \uplus \sigma_l \\ \textit{tid} = \eevalu{E_\textit{tid}}{\sigma} \\ \textit{tid} \in \sigma_o(\textit{Keys}) \\
% 		%
% 		\mathcal{A} = \eevalu{E_{\textit{Dest}}}{\sigma} \\ mc = \eevalu{E_{mc}}{\sigma} \\ mc \in P.\mathcal{M}  }
% 		%
% 		{(\textbf{E}[\textbf{send}(E_\textit{tid}, E_{\textit{Dest}}, E_{mc})], (\sigma_c, \sigma_o, (\sigma_l, x, C)),  M) \longcltstep{ \ \ \ }{t, P} (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o, (\sigma_l, x, C)),  M \cup \{ (\mathcal{A}, \addrSet, \msign{ t, mc}{\textit{tid}}) \} ) } $
		
		
% 		\kspace
		
		
% 		$ \inferrule[Recv]
% 		{
% 			\sigma = \sigma_l \uplus \sigma_o  \\  \\ (\addrSet_\textit{ori}, \addrSet_\textit{cur}, m) \in M \\ m = \msign{pa, mc}{\textit{tid}} \\\\
% 			t \in \addrSet_\textit{cur} \\ \sigma_o'\uplus \sigma_l' = \sigma\{ v_m \rightsquigarrow (pa, \textit{tid}, mc) \} \\ \dom{\sigma_l} = \dom{\sigma_l'}\\\\
% 			M' = (M \setminus \{ (\addrSet_\textit{ori}, \addrSet_\textit{cur}, m) \}) \cup \{ (\addrSet_\textit{ori}, \addrSet_\textit{cur} \setminus \{t\}, m) \}
% 		}
% 		{ (\textbf{E}[v_m \assign \textbf{recv}()], (\sigma_c, \sigma_o, (\sigma_l, x, C)), M) \longcltstep{ \ \ \ }{t, P} (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o', (\sigma_l', x, C)), M') } $
		
% 		\kspace
		
% 		$ \inferrule[WhileCont]
% 		{ \llbracket E \rrbracket_{\sigma_o \uplus \sigma_l} = \textbf{true} }
% 		{(\textbf{E}[\textbf{while}(E)C], (\sigma_c, \sigma_o, (\sigma_l, x, C')), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C;\textbf{while}(E)C], (\sigma_c, \sigma_o, (\sigma_l, x, C')), M) }
% 		$
		
% 		\kspace
		
% 		$ \inferrule[WhileEnd]
% 		{ \llbracket E \rrbracket_{\sigma_o \uplus \sigma_l} = \textbf{false} }
% 		{(\textbf{E}[\textbf{while}(E)C], (\sigma_c, \sigma_o, (\sigma_l,x, C')), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o, (\sigma_l,x, C')), M) }
% 		$	
		
% 		\kspace
		
% 		$ \inferrule[If1]
% 		{ \llbracket E \rrbracket_{\sigma_o \uplus \sigma_l} = \textbf{true} }
% 		{(\textbf{E}[\textbf{if}(E)C_1\textbf{ else } C_2], (\sigma_c, \sigma_o, (\sigma_l,x, C)), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C_1], (\sigma_c, \sigma_o, (\sigma_l,x, C)), M) } 
% 		$
		
% 		\kspace
		
% 		$ \inferrule[If2]
% 		{\llbracket E \rrbracket_{\sigma_o \uplus \sigma_l} = \textbf{false} }
% 		{(\textbf{E}[\textbf{if}(E)C_1\textbf{ else } C_2], (\sigma_c, \sigma_o, (\sigma_l,x, C)), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C_2], (\sigma_c, \sigma_o, (\sigma_l,x, C)), M) } 
% 		$
	
		
% 		\end{center}
		
% 		\vspace{0.2cm}
		
% 		\noindent \textbf{Thread transition outside method call:}
		
% 		\vspace{0.2cm}
		
% 		\begin{center}
		
% %		\begin{comment}
% 		$
% 		\inferrule[Call]
% 		{ P.L(f) = (y, C) \\ \llbracket E \rrbracket_{\sigma_c} = \textit{val} \\
% 		x \in \textsf{dom}(\sigma_c) }
% 		%
% 		{ (\textbf{E}[x\assign f(E)], (\sigma_c, \sigma_o, \circ), M) \longcltstep{(t,f,\textit{val})}{t, P} (C;\textbf{noret}, (\sigma_c, \sigma_o, (\{ y \rightsquigarrow \textit{val}\}, x, \textbf{E}[\textbf{skip}])), M) }
% 		$

% 		\kspace
		
% 		$
% 		\inferrule[Clt-Assn]
% 		{ \llbracket E \rrbracket_{ \sigma_c } = val }
% 		{ (\textbf{E}[x \assign E], (\sigma_c, \sigma_o, \circ), M) {\longcltstep{ \ \ \  }{t, P}\ (\textbf{E}[\textbf{skip}], (\sigma_c\{  x \rightsquigarrow val \}, \sigma_o, \circ), M) }}
% 		$
		
% 		\kspace
		
% 		$ \inferrule[Clt-If1]
% 		{ \llbracket E \rrbracket_{\sigma_c} = \textbf{true} }
% 		{(\textbf{E}[\textbf{if}(E)C_1\textbf{ else } C_2], (\sigma_c, \sigma_o, \circ), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C_1], (\sigma_c, \sigma_o, \circ), M) } 
% 		$
		
		
% 		\kspace
		
% 		$ \inferrule[Clt-If2]
% 		{\llbracket E \rrbracket_{\sigma_c} = \textbf{false} }
% 		{(\textbf{E}[\textbf{if}(E)C_1\textbf{ else } C_2], (\sigma_c, \sigma_o, \circ), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C_2], (\sigma_c, \sigma_o, \circ), M) } 
% 		$
		
% 		\kspace
		
% 		$ \inferrule[Clt-WhileCont]
% 		{\llbracket E \rrbracket_{\sigma_c} = \textbf{true} }
% 		{(\textbf{E}[\textbf{while}(E)C], (\sigma_c, \sigma_o, \circ), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[C;\textbf{while}(E)C], (\sigma_c, \sigma_o, \circ), M) } 
% 		$
		
% 		\kspace
		
% 		$ \inferrule[Clt-WhileEnd]
% 		{\llbracket E \rrbracket_{\sigma_c} = \textbf{false} }
% 		{(\textbf{E}[\textbf{while}(E)C], (\sigma_c, \sigma_o, \circ), M) \longcltstep{\ \ \ }{t,P} (\textbf{E}[\textbf{skip}], (\sigma_c, \sigma_o, \circ), M) } 
% 		$
		
		
% %		\end{comment}	
% 	\end{center}
	
	
	
	
% 	\kspace
	
% 	\begin{comment}
% 	\subsubsection{Multiple-Steps of Global Transition}
	
% 	%	we abbreviate $ (\exists H.\ (W,S) \longmworldstep{\ H \ } (W',S)) $ as $ (W,S) \longmworldstep{\ \ \ } (W',S) $
	
% 	$ (W,S) \longmworldstep{\ H\ } (W',S') \ \triangleq\ \exists k.\ (W,S) \longkworldstep{\ H \ }{k} (W', S') $
	
% 	\begin{center}	
% 		$
% 		\inferrule[Wzero-Step]
% 		{\ }
% 		{(W,S) \longkworldstep{\ \epsilon \ }{0} (W, S)}
% 		$
% 		\qquad 
% 		$
% 		\inferrule[W-Steps]
% 		{(W,S) \longworldstep{\ e \ } (W'',S'') \\
% 			(W'', S'') \longkworldstep{\ H' \ }{k} (W',S') }
% 		{(W,S) \longkworldstep{\ e::H' \ }{k\!\!+\!\!1} (W', S')}
% 		$
		
	
		
% 	\end{center}
% \end{comment}	
% 	\pagebreak

	
% 	\section{Byznearizablity}
		
% 	In this section we formalize correctness condition byznearizablity for distributed protocols.
	
	
% %	x \assign \textbf{faulty-call}(f, E_\textit{val}, E_\textit{tid})
	
% 	\subsection{Protocol Specification and Abstract Machine}
	
% 	\begin{longtable}{rcl}
% 		\hline
		
% 		$ (\!\textit{HistOper})\ o $ & ::= & $ (t, f, val)::(t, \texttt{ok}, val)::\epsilon $ \\
		
% 		$ (\!\textit{MemBlocks}) \ B $ & ::= & $ \{t_1 \rightsquigarrow \sigma_1, ..., t_n \rightsquigarrow \sigma_n \} $ \\
		
% 		$(\!\textit{AbsObj})\ \theta$ & $ \in $ & $ \textit{PVar} \rightharpoonup \textit{AbsVal} $\\
		
% 		$ (\!\textit{MSpec})\ \gamma  $ & $ \in $ & $ \textit{Val} \rightharpoonup \textit{AbsObj} \rightharpoonup \textit{Val} \times \textit{AbsObj} $ \\
		
% 		$ (\!\textit{PSpec}) \ \Gamma $ & ::= & $ \{ f_1 \rightsquigarrow \gamma_1, ..., f_m \rightsquigarrow \gamma_m \} $ \\
		
% 		$ (\!\textit{AbsStmt})\ \mathbb{C} $& ::= &  $ C \mid \textbf{fexec}(f, val, \textit{tid}) \mid \textbf{fret}(val) $ \\
% 		&&  $ \mid  \textbf{aftermath}(H) $ \\
		
% 		$ (\!\textit{AbsProg})\ \ \mathbb{W} $ & ::= & $ \textbf{with } \Gamma \textbf{ do } \mathbb{C} \parallel ... \parallel \mathbb{C} $ \\
		
% 		$ (\!\textit{AbsStk})\ \textit{ak} $ & ::= & $ (x, \mathbb{C}) \mid \circ $\\
		
% 		$ (\!\textit{AbsLocState})\ \textit{al} $ & ::= & $ (\sigma_c, \theta, ak) $\\
		
% 		$ (\!\textit{AbsPool})\ \mathbb{K} $ & ::= & $ \{ t_1 \rightsquigarrow ak_1, ..., t_n \rightsquigarrow ak_n \} $\\
		
% 		$ (\!\textit{AbsState})\ \mathbb{S}  $& ::= & $ (B_c, \theta, \mathbb{K}) $\\
% 		\hline
% 	\end{longtable}
	

% 	\subsection{Abstract Operational Semantics}
	
% %	\kcomment{白茫茫大地真干净！}
	
% 	\begin{center}	
		
% 		$ \inferrule[AGlb-Int]
% 		{  (\mathbb{C}_t, (B_c(t), \theta, \mathbb{K}(t))) \longbulletarrow{\ H \ }_{t, \Gamma} (\mathbb{C}_t', (\sigma_c', \theta', ak') )  }
% 		%
% 		{ (\textbf{with }\Gamma \textbf{ do } \mathbb{C}_1 \parallel ...\mathbb{C}_t ... \parallel \mathbb{C}_n, (B_c, \theta, \mathbb{K})) \longcircarrow{\ H\ } (\textbf{with }\Gamma \textbf{ do } \mathbb{C}_1 \parallel ...\ \mathbb{C}_t'\ ... \parallel \mathbb{C}_n, (B_c\{t \rightsquigarrow \sigma_c'\}, \theta', \mathbb{K}\{ t \rightsquigarrow ak' \}) ) }
% 		$
		
% 		\kspace
		
% 		$
% 		\inferrule[AGlb-Crash]
% 		{ \not\exists H.\ \mathbb{C}_t = \textbf{aftermath}(H) \\ \mathbb{C}_t \neq \textbf{skip} \\ B_c(t)(\textit{faulty}) = \textbf{true} \\ o1, ..., o_m \in \textit{HistOper} }
% 		{ (\textbf{with } \Gamma \textbf{ do } \mathbb{C}_1 \parallel ... \ \mathbb{C}_t\ ... \parallel \mathbb{C}_n,\ (B_c, \theta, \mathbb{K})) \longcircarrow{(t, \texttt{stop})::\epsilon} (\textbf{with } \Gamma \textbf{ do } \mathbb{C}_1 \parallel ...\ \textbf{aftermath}(o_1::...::o_m) \ ... \parallel \mathbb{C}_n,\ (B_c, \theta, \mathbb{K})) }
% 		$
		
		
% 		\kspace
		
% 		$ \inferrule[ACall]
% 		{ f \in \textsf{dom}(\Gamma) \\
% 			\llbracket E \rrbracket_{ \sigma_c } = val \\
% 			x \in \textsf{dom}(\sigma_c)  \\  i \in  \sigma_c(\textit{Keys}) }
% 		{ (\textbf{E}[x\assign f(E)] , (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t, \Gamma} (\textbf{fexec}(f, val, i), (\sigma_c, \theta, (x, \textbf{E}[\textbf{skip}]) )) } $
		
		
% 		\kspace
		
% 		\begin{comment}
% 		$ \inferrule[AFaulty-Call]
% 		{	\sigma_c(\textit{faulty}) = \textbf{true} \\ 
% 			f \in \textsf{dom}(\Gamma) \\
% 			\llbracket E_\textit{val} \rrbracket_{ \sigma_c } = val \\
% 			\llbracket E_\textit{tid} \rrbracket_{ \sigma_c } = \textit{tid} \\
% 			\textit{tid} \in \sigma_c(\textit{Keys}) \\
% 			x \in \textsf{dom}(\sigma_c) \\  }
% 		{ (\textbf{E}[x\assign \textbf{faulty-call}(f, E_\textit{val}, E_\textit{tid})] , (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t, \Gamma} (\textbf{fexec}(f, val, \textit{tid}), (\sigma_c, \theta, (x, \textbf{E}[\textbf{skip}]) )) } $
		
% 		\kspace
		
% 		\end{comment}
		
		
% 		$ \inferrule[AExec]
% 		{  	\Gamma(f)(val)(\theta) = (val', \theta') }
% 		{(\textbf{fexec}(f, val, \textit{tid}) , (\sigma_c, \theta, ak)) \longbulletarrow{ (\textit{tid}, f, val)::(\textit{tid}, \texttt{ok}, val')::\epsilon }_{ t, \Gamma} (\textbf{fret}(val'), (\sigma_c, \theta', ak))  } $
		
		
% 		\kspace
		
% 		$ \inferrule[AFret]
% 		{ \ }
% 		{(\textbf{fret}(val') , (\sigma_c, \theta, (x, {C}))) \longbulletarrow{\ \epsilon \ }_{t, \Gamma} ({C}, (\sigma_c\{ x \rightsquigarrow val' \},\theta, \circ))  } $
% 		\qquad
% 		$ \inferrule[AAssn]
% 		{ \eevalu{E}{\sigma_c} = val }
% 		{(\textbf{E}[x \assign E], (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t,\Gamma} (\textbf{E}[\textbf{skip}], (\sigma_c\{ x \rightsquigarrow  val \}, \theta, \circ)) } 
% 		$
		
% 		\kspace
		
% 		$ \inferrule[AStop]
% 		{ \  \sigma_c(\textit{faulty}) = \textbf{true} \\ o_1, ..., o_m \in \textit{HistOper}}
% 		{(\textbf{E}[\textbf{stop}], (\sigma_c, \theta, \circ)) \longbulletarrow{(t, \texttt{stop})::\epsilon}_{t,\Gamma} (\textbf{aftermath}(o_1::...::o_m), (\sigma_c, \theta, \circ)) } 
% 		$
		
		
% 		\kspace
		
% 		$ \inferrule[AAftermath]
% 		{ \ o = (t, f, val)::(t, \texttt{ok}, val')::\epsilon \\ t \in \sigma_c(\textit{Keys}) \\ f \in \dom{\Gamma} \\ \Gamma(f)(val)(\theta) = (val', \theta')}
% 		{(\textbf{aftermath}(o::H'), (\sigma_c, \theta, \circ)) \longbulletarrow{\ o\ }_{t,\Gamma} (\textbf{aftermath}(H'), (\sigma_c, \theta', \circ)) } 
% 		$
		
		
% 		\kspace
		
			
% 		$ \inferrule[AIf1]
% 		{ \llbracket E \rrbracket_{\sigma_c} = \textbf{true} }
% 		{(\textbf{E}[\textbf{if}(E) \mathbb{C}_1\textbf{ else } \mathbb{C}_2], (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t, \Gamma} (\textbf{E}[\mathbb{C}_1], (\sigma_c, \theta, \circ)) } 
% 		$\qquad
% 		$ \inferrule[AIf2]
% 		{ \llbracket E \rrbracket_{\sigma_c} = \textbf{false} }
% 		{(\textbf{E}[\textbf{if}(E) \mathbb{C}_1\textbf{ else } \mathbb{C}_2], (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t, \Gamma} (\textbf{E}[\mathbb{C}_2], (\sigma_c, \theta, \circ)) } 
% 		$
		
% 		\kspace
		
% 		$ \inferrule[AWhileCont]
% 		{ \llbracket E \rrbracket_{\sigma_c} = \textbf{true} }
% 		{(\textbf{E}[\textbf{while}(E)\mathbb{C}], (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t,\Gamma} (\textbf{E}[\mathbb{C};\textbf{while}(E)\mathbb{C}], (\sigma_c, \theta, \circ)) } 
% 		$\qquad
% 		$ \inferrule[AWhileEnd]
% 		{ \llbracket E \rrbracket_{\sigma_c} = \textbf{false} }
% 		{(\textbf{E}[\textbf{while}(E) \mathbb{C}], (\sigma_c, \theta, \circ)) \longbulletarrow{\ \epsilon \ }_{t,\Gamma} (\textbf{E}[\textbf{skip}], (\sigma_c, \theta, \circ)) } 
% 		$
		
		
		
% 	% \end{center}
	
% %	注意这里\ifrule{AStop} 前条件要求$ ak $为空，与\ifrule{Stop}中$ \kappa \neq \circ $不一样
	
% 	\begin{comment}
		
	
% 	\subsection{Multiple-Steps of Abstract Global Transition}
	
% 	\vspace{0.2cm}
% 	\begin{center}
% 		$
% 		\inferrule[AWzero-Step]
% 		{\ }
% 		{(\mathbb{W},\mathbb{S}) \longmcircarrow{\ \epsilon\ } (\mathbb{W}, \mathbb{S}) }
% 		$
% 		\qquad
% 		$
% 		\inferrule[AWe-Steps]
% 		{(\mathbb{W}, \mathbb{S}) \longcircarrow{\ H_1 \ } (\mathbb{W}'', \mathbb{S}'') \\
% 			(\mathbb{W}'', \mathbb{S}'') \longmcircarrow{\ H_2\ } (\mathbb{W}', \mathbb{S}') }
% 		{(\mathbb{W},\mathbb{S}) \longmcircarrow{\ H_1::H_2\ } (\mathbb{W}', \mathbb{S}') }
% 		$
% 	\end{center}
% 	\end{comment}
	
	
	
% 	\begin{itemize}
% 		\item 为了建模"扮演"，函数调用语句 $ x \assign f(E) $ 是非确定性的。由\textit{Keys}的初始定义(见Initial abstract world configuration定义)，correct client只能以自己的名义执行$ f $，但faulty client可以非确定地以某个faulty client的名义执行$ f $
% 		\item 为了建模"余波"，定义$ \textbf{aftermath}(H) $语句
% 	\end{itemize}
	
% 	\kspace
	
% 	\subsection{Byznearizable relation between histories}
	
% 	the following are some trivial predicates and a function for events: 
	
	
% 	$$
% 	\begin{array}{l}
% 		 \textsf{is-inv}(e)\ \triangleq\ \exists t,f,val.\ e = (t,f,val) \\
% 		 \textsf{is-res}(e)\ \triangleq\ \exists t , val.\  e = (t,\texttt{ok},val) \\
% 		 \textsf{is-stop}(e)\ \triangleq\ \exists t.\  e = (t, \texttt{stop}) \\		
% 	\end{array}
% 	\qquad
% 	\textsf{get-tid}(e)\  \triangleq\ \left\{
% 	\begin{array}{ll}
% 	t & \textsf{if }e = (t, \wildcard, \wildcard)  \\
% 	t & \textsf{if }e = (t, \texttt{stop})  \\
% 	\textit{undefined} & \textit{o.w.}
% 	\end{array}
% 	\right.$$
	
% 	\vspace{0.3cm}
	
% 	the following are functions for history, note that $ H(i) $ is the i-th event in $ H $, $ H|_t $ is the projection of history $ H $ on thread t, we also call $ H|_t $ a $ \textit{t-component} $ of $ H $. We use $ |H| $ to represent the length of history $ H $.
% 	%
% 	$$ H(i)\ \triangleq\ \left\{
% 	\begin{array}{ll}
% 	H'(i-1) & \textsf{if } i > 1 \land H = e::H'\\
% 	e & \textsf{if } i = 1 \land H = e::H'\\
% 	\textit{undefined} & \textit{o.w.}
% 	\end{array}
% 	\right.
% 	\qquad
% 	|H| \ \triangleq\ \left\{
% 	\begin{array}{ll}
% 		1 + |H'| & \textsf{if } H = e::H' \\
% 		0 & \textit{o.w.}
% 	\end{array}
% 	\right.
% 	 $$ 
	
	
% 	$$ H|_t \ \triangleq \ \left\{
% 	\begin{array}{ll}
% 		\epsilon & \textsf{if }H ::= \epsilon \\
% 		e :: H'|_t & \textsf{if }(H ::= e::H') \land (t = \textsf{get-tid}(e))\\
% 		H'|_t & \textit{o.w.}
% 	\end{array}
% 	\right.
% 	$$
	
	
% 	\begin{comment}
		
	
	
% 	\begin{definition}{{A response $ e' $ \textit{matches} an invocation $ e $ in $ H $, denoted $\textsf{match}(e, e') $}, if they have the same thread id:}
		
% 		$ \textsf{match}(e,e') \triangleq \textsf{is-inv}(e) \land \textsf{is-res}(e') \land (\textsf{get-tid}(e) = \textsf{get-tid}(e')) $
		
% 	\end{definition}
	
% 	\begin{definition}{{A History }$ H ${ is }\textit{seqential}{ iff 
% 		\begin{itemize}
% 			\item the first event is an invocation or stop
% 			\item every response ared followed a inv or stop: 
% 			\item dfg
% 		\end{itemize}}}
		
% 		$ \textsf{seq}(H) \triangleq \left\{
% 		\begin{array}{ll}
% 		\textbf{true} & \textsf{if } H = \epsilon \\
% 		\textsf{is-inv}(e) & \textsf{if }	H = e::\epsilon	\\
% 		\textsf{match}(e, e') \land \textsf{seq}(H') & \textsf{if } H = e::e'::H' 
% 		\end{array}
% 		\right. $
		
% 	\end{definition}
	
	
% 	\begin{definition}{{A history} $ H $ is \textit{well-formed} iff $ H|_t $ is sequential for all $ t $:}
		
% 		$ \textsf{well-formed}(H) \triangleq \forall t.\  \textsf{seq}(H|_t)$
% 	\end{definition}

% 	The well-formedness formalize two properties of history. First, it ensures all responses have corresponding invocation. Second, the history projection on each thread is "sequential". 
	
	
% 	\begin{definition}{{An \textit{extensions} of $ H $, denoted \textsf{extensions}$ (H) $, is a set of histories constructed by appending responses to zero or more pending invocations of $ H $}}
		
% 		$\textsf{extensions} (H) \triangleq \{ H' \mid \exists H_\textit{ok}.\  (H' = H::H_\textit{ok}) \land \textsf{well-formed}(H') \land \forall i.\  \textsf{is-res}(H_\textit{ok}(i))  \} $
% 	\end{definition}
	
% 	\begin{definition}{{The \textit{complete} histories of $ H $, denoted $ \textsf{completions}(H)$, is a set of subsequences of $ \textsf{extensions}(H) $ consisting of all matching invocations and responses}: }
		
% 		$ \textsf{completions}(H) \triangleq \{ \textsf{truncate}(H') \mid H' \in \textsf{extensions}(H) \} $
		
% 		\vspace{0.2cm}
		
% 		where \textit{truncate}$ (H) $ is the maximal complete sub-history of $ H $:
		
% 		$ \textsf{truncate}(H) \triangleq \left\{
% 		\begin{array}{ll}
% 		\epsilon & H = \epsilon \\
% 		e::\textsf{truncate}(H') & \textsf{if } H = e::H' \land (\textsf{is-res}(e) \lor \exists i.\  \textsf{match}(e, H(i))) \\
% 		\textsf{truncate}(H') & \textsf{if } H = e::H' \land (\lnot (\textsf{is-res}(e) \lor \exists i.\  \textsf{match}(e, H(i)))) \\
% 		\end{array}
% 		\right. $
		
% 	\end{definition}
	
% 	\begin{comment}
% 		\begin{definition}{{two histories are }\textit{weakly equivalent} {iff their projection to each thread are equal}:}
		
% 		$ H \equiv H'\ \triangleq \ \forall t.\  H|_t = H'|_t $
		
% 		\end{definition}
% 	\end{comment}
	
% 	\begin{definition}[\textbf{byznearizable relation}] A history $ H $ is \textit{linearizable} to $ H' $ \textit{w.r.t.} thread set $ \clientSet $ and  $ \faultyClients $, denoted $ H \preceq_\textsf{lin}^{\clientSet, \faultyClients} H' $ iff 


% 	\quad $ \begin{array}{ll}
% 		\textsf{byz1. }  (\forall t \in \clientSet.\ H|_t = H'|_t)  \\
% 		\textsf{byz2. } (\exists \pi.\ (\forall i_1, i_2.\ \pi(i_1) = \pi(i_2) \implies i_1 = i_2) \land (\forall i.\ H(i) = H'(\pi(i)))\\
% 		 \qquad \qquad  \land \ (\forall i, j.\ (i < j) \land (\textsf{is-res}(H(i)) \lor  \textsf{is-stop}(H(i))) \land (\textsf{is-inv}(H(j)) \lor \textsf{is-stop}(H(j)) ) \implies \pi(i) < \pi(j))\\
% 		\textsf{byz3. } (\forall t \in \faultyClients.\ (\exists i.\ H(i) = (t,\texttt{stop}))) \implies (\forall t \in \faultyClients.\ \exists n.\ |\{ i \mid \textsf{get-tid}(H'(i)) = t \}| \leq n))  \\
		
% %		& \land \ (\forall t \in \faultyClients.\ (t,\texttt{stop}) \in H) \implies (\forall t.\ (\exists H_1', H_2'.\ H' = H_1:: (t, \texttt{stop}) ::H_2) \land (\exists n.\ |\{ i \mid \textsf{get-tid}(H_2(i)) = t \}| \leq n))  \\
% 		\end{array} $
		
% 		\vspace{0.2cm}
		
% %		$ e \in H \ \triangleq \ \exists H_1, H_2.\ H = H_1::e::H_2 $
		
		
% 	\end{definition}


% 	\subsubsection{Byznearizable Protocol}
	
% %	A linearizable object is one whose concurrent histories are linearizable w.r.t. some sequential specification. To define linearizability, we first need to define what is \textit{object's concurrent histories}. So we formalize the set of histories generated by the set of programs under following restriction:
% %	\begin{itemize}
% %		\item all acceptor threads in the program run and only run $ \kacc() $ in the beginning
% %		\item all proposer threads could run all possible statements which use function $ \kpropP $ only
% %	\end{itemize}
	
% 	\begin{definition}[\textbf{Produce Concurrent History}]\ history $ H $ is produced by executing $ W $ from state $ S $
		
% 		\vspace{0.2cm}
		
% 		$\inferrule[]
% 		{(W,S) \longworldstep{\ e \ } (W',S') \\ \textsf{Hist}(W',S',H') }
% 		{\textsf{Hist}(W,S,e::H')}$
% 		\quad
% 		$\inferrule[]
% 		{(W,S) \longworldstep{\ \ \ } (W',S') \\ \textsf{Hist}(W',S',H) }
% 		{\textsf{Hist}(W,S,H)}$
		
% 	\end{definition}
	
% 	\begin{definition}[\textbf{Produce Sequential History}]\ history $ H $ is produced by executing $ \mathbb{W} $ from state $ \mathbb{S} $
		
% 		\vspace{0.2cm}
		
% 		$\inferrule[]
% 		{(\mathbb{W},\mathbb{S}) \longcircarrow{\ H_1 \ } (\mathbb{W}',\mathbb{S}') \\ \textsf{Hist}(\mathbb{W}',\mathbb{S}',H_2) }
% 		{\textsf{Hist}(\mathbb{W},\mathbb{S},H_1::H_2)}$

% 	\end{definition}
	
% 	\vspace{0.2cm}
	
% 	\begin{definition}[\textbf{Initial World Configuration}]\ 
		
% 		$ \begin{array}{ll}
% 			(W, (\varDelta, \emptyset)) = \textsf{pInit}_{\clientSet, \faultyClients, \replicaSet, \faultyReplica}(P, B_o) \ \triangleq \  & \textsf{well-formed}_{P, \clientSet, \faultyClients, \replicaSet, \faultyReplica}(W, (\varDelta, \emptyset)) \\
			
% 			& \land \ (\forall t \in \replicaSet.\ C_t = P.C_{\textit{serv}} )\\
			
% 			& \land\  (\forall t \in \replicaSet \uplus \faultyReplica.\ \varDelta(t).\sigma_o = B_o(t))\\
			
% 			& \land \ (\forall t \in \clientSet.\ \varDelta(t).\kappa = \circ )  \land (\forall t \in \faultyClients \uplus \replicaSet \uplus \faultyReplica.\ \varDelta(t).\kappa = (\emptyset, \wildcard, \textbf{skip}) )  \\
			
% %			& \land \ (\forall t \in \clientSet \uplus \faultyClients \uplus \replicaSet \uplus \faultyReplica.\ (\varDelta(t).\sigma_o)(\inbuf) = \emptyset  )
			
% 			& {\land \ (\forall t \in \faultyClients.\ \exists C.\ C_t = C;\textbf{stop})}
% 		\end{array} $
% 	\end{definition}
	
% 	\textsf{pInit}意味着
% 	\begin{itemize}
% 		\item 正确的replica线程初始程序只能是协议的服务程序$ C_\textit{serv} $，故障的(\textit{faulty} = \textbf{true}的) replica线程的初始程序不做任何限制
		
% 		\item faulty client的初始程序一定是某个程序$ C $与\textbf{stop}语句的串联. 用于标记faulty client的终止
		
% 		\item $ B_o $用于初始化所有replica线程的初始local object state $ \sigma_o $
		
% 		\item 所有replica和faulty client线程的local stack 初始都是$ (\emptyset, \wildcard, \textbf{skip}) $. 这是为了符合语义规则，使replica线程能不经函数调用执行\textbf{send}, \textbf{recv}语句({\color{red} 这样定义可能可读性上有些问题})
% %		\item 所有线程初始时的接收缓冲池为空(\textit{Inbuf})

% 	\end{itemize}
	
	
% 	\begin{definition}[\textbf{Concurrent Histories}]\ 
		 
% 		$ \histSet{P, B_o, \clientSet, \faultyClients} \ \triangleq\ \left\{ H \ \middle\vert  \begin{array}{ll}
% 			\exists {W}, {S}, \replicaSet, \faultyReplica.\ ({W}, {S}) = \textsf{pInit}_{\clientSet, \faultyClients, \replicaSet, \faultyReplica}(P, B_o) \ 
% 			\land \ \textsf{Hist}({W}, {S}, H) 
% 		\end{array}  \right\} $
% 	\end{definition}
	
	
	
% 	\begin{definition}[\textbf{Initial Abstract World Configuration}]\ 
		
		
% 		$ \begin{array}{ll}
% 			(\mathbb{W}, (B_c, \theta, \mathbb{K})) = \textsf{aInit}_{\clientSet, \faultyClients}(\Gamma, \theta) \ \triangleq \ & \exists n. \ \exists i_1, ..., i_n. \ \exists {C}_{i_1}, ..., {C}_{i_n}.\ \clientSet \uplus \faultyClients  = \{ i_1, ..., i_n \} \land (\mathbb{W} = \textbf{with} \ \Gamma \textbf{ do } {C}_{i_1} \parallel ... \parallel {C}_{i_n})\\
			
% %			\land\  (\forall t \in \clientSet.\ B_c(t)(\textit{faulty}) = \textbf{false} ) \land (\forall t \in \faultyClients.\ B_c(t)(\textit{faulty}) = \textbf{true} )\\
			
% %			\land\  (\forall t \in \faultyClients.\ B_c(t)(\textit{F}_c) = \faultyClients) \\
			
% 			& \land \ (\forall t \in \clientSet.\ B_c(t)(\textit{faulty}) = \textbf{false} \land B_c(t)(\textit{Keys}) = \{t\} ) \\
			
% 			& \land \ (\forall t \in \faultyClients.\ B_c(t)(\textit{faulty}) = \textbf{true} \land B_c(t)(\textit{Keys}) = \faultyClients) \\
			
% 			& \land \ (\forall t \in \clientSet \uplus \faultyClients.\ (\mathbb{S}.\mathbb{K})(t) = \circ)  \\
			
			
% 			& {\land \ (\forall t \in \faultyClients.\ \exists {C}.\ {C}_t = C;\textbf{stop})}\\
			
% 		\end{array} $
% 	\end{definition}
	
% 	\textsf{aInit}意味着
% 	\begin{itemize}
% 		\item 正确的replica线程的初始程序只能有$ \textit{Stmt} $中定义的语句(即初始程序中没有\textbf{faulty-call}语句)
		
% 		\item faulty client的初始程序一定是某个程序$ C $与\textbf{stop}语句的串联. 用于标记faulty client的终止
		
% %		\item faulty client初始程序中有$ \textbf{aftermath}(H) $,其中$ H $还是infinite的怎么办，能不能将aftermath和faulty-call统一起来？
		
% 	\end{itemize}
	
	
% 	\begin{definition}[\textbf{Legal Sequential Histories}]
% 	The set of all {\textit{legal sequential histories}} of protocol spec $ \Gamma $ and initial $ \theta $ \textit{w.r.t.} client set $ \clientSet $ and faulty client set $ \faultyClients $ is defined as follow:
	
% 	$ \absHistSet{\Gamma, \theta, \clientSet, \faultyClients} \ \triangleq \ \left\{ H \ \middle\vert  \begin{array}{ll}
% 		\exists \mathbb{W}, \mathbb{S}.\ (\mathbb{W}, \mathbb{S}) = \textsf{aInit}_{\clientSet, \faultyClients}(\Gamma, \theta) \ 
% 		\land \ \textsf{Hist}(\mathbb{W}, \mathbb{S}, H)  )
% 	\end{array}  \right\} $
% 	\end{definition}
	
% 	\vspace{0.2cm}
	
	
% 	\begin{comment}
% 	\begin{definition} [\textbf{Consensus Sequential Specification}]\ 
		
% 		$ \textsf{Gamma}(f) \ \triangleq \ \{ f  \rightsquigarrow \texttt{FP} \} $
		
% 		where 
% 		$$\begin{array}{ll}\			
% 			\texttt{FP}(pval)(\theta)\ \triangleq\ \left\{  
% 			\begin{array}{ll}
% 				(pval, \theta\{ \texttt{COBJ} \rightsquigarrow pval \}) & \textsf{if } (\theta(\texttt{COBJ}) = \texttt{undef}) \land (pval \neq \texttt{undef})\\
% 				(val, \theta) & \textsf{if } (\theta(\texttt{COBJ}) = val) \land (val \neq \texttt{undef})\\
				
% 				%				\textit{undefined} & \textit{o.w. }\\
% 			\end{array}
% 			\right.\\
% 		\end{array}$$
	
% 	\vspace{0.2cm}
% 	and $ \texttt{COBJ} $ is the program variable name of any {abstract} consensus object
		
% 	general initial object:	
% 		$$ \theta_\texttt{ini} \ \triangleq \ \{ \texttt{COBJ} \rightsquigarrow \texttt{undef} \} $$
	
% 	\end{definition}
	
% 	\end{comment}
	
% %	物理地址：$\xi_i$
	
	
	
	
% 	\begin{comment}
% 	\begin{definition}[\textbf{Byznearizability}] {$ P \preceq_{\varphi} \Gamma $ iff}
		
% 		$ \begin{array}{ll}
% 		\forall B_o, \clientSet, \faultyClients, H.\  H \in \histSet{P, B_o, \clientSet, \faultyClients} \implies & (\exists H_c,H'.\ H_c \in \red{\textsf{completions}}(H) \land H' \in \absHistSet{\Gamma, \varphi(B_o), \clientSet, \faultyClients} 
% 		  \land (H_c \preceq_\textsf{lin}^{\clientSet, \faultyClients} H'))
% 		\end{array} $
% 	\end{definition}
	
% 	\begin{itemize}
% 		\item \red{由于$ H $可能infinite，我不是很明白completion怎么做。我想也许可以修改abstract machine 生成history的语义，使之前成总是对出现的function inv和res改为末尾(指线程t的分量的末尾)可以出现仅function inv事件的情形，这样就不需要用$ H $的complete(而直接用$ H $)来反映byz1和byz2}
% 	\end{itemize}
% 	\end{comment}

% 	\begin{definition}[\textbf{Byznearizability}] {$ P \preceq_{\varphi} \Gamma $ iff}
		
% 		$ \begin{array}{ll}
% 			\forall B_o, \clientSet, \faultyClients, H.\  H \in \histSet{P, B_o, \clientSet, \faultyClients} \implies & (\exists H'.\ H' \in \absHistSet{\Gamma, \varphi(B_o), \clientSet, \faultyClients} 
% 			\land (H \preceq_\textsf{lin}^{\clientSet, \faultyClients} H'))
% 		\end{array} $
% 	\end{definition}
	
	
% 	\begin{itemize}
% 		\item 由于这里的history是由$ \textsf{Hist}(W,S,H) $定义，若history on 某thread的projection是有限长的，则我认为该线程不会有pending invocation, 若无限长，就也不用考虑pending的问题了。所以我没有定义completion
% 	\end{itemize}
	
% 	\pagebreak
	
	
\end{small}


\end{document}